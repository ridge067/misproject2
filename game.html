<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Pac-Man Game</title>
  <link rel="stylesheet" href="styles.css">
  <script src="script.js" defer></script>
  <audio id="pacmanMusic" loop>
    <source src="https://www.sounds-resource.com/download/5309/" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <style>
    .pacman-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      margin: 2rem 0;
    }

    .game-header {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 560px;
      background: var(--card);
      padding: 1rem;
      border-radius: 8px;
      box-shadow: var(--card-shadow);
      color: var(--text);
      font-weight: bold;
      font-size: 1.1rem;
    }

    .game-header div {
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    .game-canvas {
      width: 560px;
      height: 560px;
      background: #000000;
      border: 4px solid var(--accent);
      border-radius: 8px;
      display: block;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    .game-controls {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .game-info {
      text-align: center;
      color: var(--text);
      font-size: 1rem;
    }

    .game-info p {
      margin: 0.5rem 0;
    }

    .key-hint {
      color: var(--muted);
      font-size: 0.9rem;
      text-align: center;
      margin-top: 1rem;
    }
  </style>
  </head>
<body>
  <header role="banner">
    <nav class="container" aria-label="Main navigation">
      <div class="nav-inner">
        <a href="index.html" class="logo" aria-label="Luke Ridgeway Home">Luke Ridgeway</a>
        <button class="nav-toggle" aria-label="Toggle navigation menu">â˜°</button>
        <div class="nav-links">
          <a href="index.html">Home</a>
          <a href="hobbies.html">Hobbies</a>
          <a href="discover.html">Discover</a>
          <a href="resume.html">Resume</a>
          <a href="career.html">Career</a>
          <a href="game.html" aria-current="page">Game</a>
        </div>
        <button class="dark-mode-toggle" aria-label="Toggle theme">Theme: Dark</button>
      </div>
    </nav>
  </header>
  
  <main class="container" role="main">
    <header>
      <h1>Pac-Man Game</h1>
      <p class="lead">Eat all the pellets while avoiding ghosts! Collect power-ups to turn the tables.</p>
    </header>

    <div class="pacman-container">
      <div class="game-header">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Pellets: <span id="pelletsLeft">0</span></div>
      </div>

      <canvas id="gameCanvas" class="game-canvas" width="560" height="560"></canvas>

      <div class="game-info">
        <p id="gameStatus">Press Start Game to begin!</p>
        <div class="key-hint">Use Arrow Keys to move Pac-Man â€¢ Space to pause/resume</div>
      </div>

      <div class="game-controls">
        <button onclick="startGameWithSound()" class="download-btn">Start Game</button>
        <button onclick="pacmanGame.togglePause()" class="download-btn">Pause</button>
        <button onclick="pacmanGame.resetGame()" class="download-btn">Reset</button>
      </div>
    </div>
  </main>
  
  <footer role="contentinfo">
    <div class="container">
      <div class="footer-content">
        <p>&copy; 2025 Luke Ridgeway. All rights reserved.</p>
        <p>Built with HTML5, CSS3, and JavaScript</p>
      </div>
    </div>
  </footer>

  <script>
    class PacManGame {
      constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Game dimensions
        this.gridSize = 20; // Each cell is 20x20 pixels
        this.cols = this.canvas.width / this.gridSize; // 28 columns
        this.rows = this.canvas.height / this.gridSize; // 28 rows
        
        // Game state
        this.gameRunning = false;
        this.gamePaused = false;
        this.gameOver = false;
        this.won = false;
        
        // Score and lives
        this.score = 0;
        this.lives = 3;
        this.pelletsEaten = 0;
        this.totalPellets = 0;
        
        // Pac-Man
        this.pacman = {
          x: 13,
          y: 23,
          direction: 0, // 0=right, 1=down, 2=left, 3=up
          nextDirection: 0,
          mouthOpen: true,
          mouthTimer: 0
        };
        
        // Ghosts with different AI behaviors
        this.ghosts = [
          { x: 13, y: 7, color: '#FF0000', mode: 'chase', targetX: 0, targetY: 0, name: 'Blinky' },
          { x: 12, y: 9, color: '#FFB8FF', mode: 'chase', targetX: 0, targetY: 0, name: 'Pinky' },
          { x: 13, y: 9, color: '#00FFFF', mode: 'chase', targetX: 0, targetY: 0, name: 'Inky' },
          { x: 14, y: 9, color: '#FFB897', mode: 'chase', targetX: 0, targetY: 0, name: 'Clyde' }
        ];
        
        this.powerUpActive = false;
        this.powerUpTimer = 0;
        this.powerUpDuration = 300; // 5 seconds at 60fps
        
        // Maze
        this.maze = this.generateMaze();
        
        // Input handling
        this.keys = {};
        this.setupInputHandlers();
        
        // Game loop
        this.frameCount = 0;
      }
      
      generateMaze() {
        // 0 = walkable, 1 = wall
        const maze = Array(this.rows).fill(null).map(() => Array(this.cols).fill(0));
        
        // Create outer walls
        for (let x = 0; x < this.cols; x++) {
          maze[0][x] = 1;
          maze[this.rows - 1][x] = 1;
        }
        for (let y = 0; y < this.rows; y++) {
          maze[y][0] = 1;
          maze[y][this.cols - 1] = 1;
        }
        
        // Create internal walls
        const wallPatterns = [
          { x: 1, y: 1, w: 6, h: 4 },
          { x: 8, y: 1, w: 6, h: 4 },
          { x: 15, y: 1, w: 6, h: 4 },
          { x: 22, y: 1, w: 6, h: 4 },
          { x: 1, y: 7, w: 3, h: 3 },
          { x: 10, y: 7, w: 3, h: 3 },
          { x: 15, y: 7, w: 3, h: 3 },
          { x: 24, y: 7, w: 3, h: 3 },
          { x: 5, y: 12, w: 4, h: 3 },
          { x: 19, y: 12, w: 4, h: 3 },
          { x: 1, y: 18, w: 6, h: 3 },
          { x: 10, y: 18, w: 6, h: 3 },
          { x: 15, y: 18, w: 6, h: 3 },
          { x: 22, y: 18, w: 6, h: 3 }
        ];
        
        wallPatterns.forEach(pattern => {
          for (let y = pattern.y; y < pattern.y + pattern.h; y++) {
            for (let x = pattern.x; x < pattern.x + pattern.w; x++) {
              if (y >= 0 && y < this.rows && x >= 0 && x < this.cols) {
                maze[y][x] = 1;
              }
            }
          }
        });
        
        return maze;
      }
      
      generatePellets() {
        this.pellets = [];
        this.powerUps = [];
        
        for (let y = 1; y < this.rows - 1; y++) {
          for (let x = 1; x < this.cols - 1; x++) {
            if (this.maze[y][x] === 0) {
              // Empty space, add pellet
              const distance = Math.abs(x - this.pacman.x) + Math.abs(y - this.pacman.y);
              if (distance > 2) {
                this.pellets.push({ x, y, eaten: false });
              }
            }
          }
        }
        
        // Add power-ups in corners
        this.powerUps = [
          { x: 1, y: 1 },
          { x: 26, y: 1 },
          { x: 1, y: 26 },
          { x: 26, y: 26 }
        ];
        
        this.totalPellets = this.pellets.length;
        this.updateUI();
      }
      
      setupInputHandlers() {
        document.addEventListener('keydown', (e) => {
          this.keys[e.key] = true;
          
          if (e.key === ' ') {
            e.preventDefault();
            this.togglePause();
          }
          
          // Arrow key handling
          if (e.key === 'ArrowUp') {
            this.pacman.nextDirection = 3;
            e.preventDefault();
          }
          if (e.key === 'ArrowDown') {
            this.pacman.nextDirection = 1;
            e.preventDefault();
          }
          if (e.key === 'ArrowLeft') {
            this.pacman.nextDirection = 2;
            e.preventDefault();
          }
          if (e.key === 'ArrowRight') {
            this.pacman.nextDirection = 0;
            e.preventDefault();
          }
        });
        
        document.addEventListener('keyup', (e) => {
          this.keys[e.key] = false;
        });
      }
      
      startGame() {
        this.gameRunning = true;
        this.gamePaused = false;
        this.gameOver = false;
        this.won = false;
        this.score = 0;
        this.lives = 3;
        this.pelletsEaten = 0;
        this.powerUpActive = false;
        this.frameCount = 0;
        
        this.pacman.x = 13;
        this.pacman.y = 23;
        this.pacman.direction = 0;
        
        this.ghosts.forEach((ghost, i) => {
          ghost.x = 12 + i - 1;
          ghost.y = 9;
        });
        
        this.generatePellets();
        this.updateUI();
        this.gameLoop();
      }
      
      togglePause() {
        if (!this.gameRunning) return;
        this.gamePaused = !this.gamePaused;
        const statusEl = document.getElementById('gameStatus');
        statusEl.textContent = this.gamePaused ? 'â¸ PAUSED' : 'Playing...';
      }
      
      resetGame() {
        this.gameRunning = false;
        this.gamePaused = false;
        this.gameOver = false;
        this.won = false;
        document.getElementById('gameStatus').textContent = 'Press Start Game to begin!';
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }
      
      gameLoop() {
        if (!this.gameRunning) return;
        
        if (!this.gamePaused) {
          this.update();
        }
        
        this.draw();
        requestAnimationFrame(() => this.gameLoop());
      }
      
      update() {
        // Update power-up timer
        if (this.powerUpActive) {
          this.powerUpTimer--;
          if (this.powerUpTimer <= 0) {
            this.powerUpActive = false;
            this.ghosts.forEach(g => g.mode = 'chase');
          }
        }
        
        // Try to move Pac-Man in the desired direction
        if (this.frameCount % 6 === 0) { // Pac-Man moves every 6 frames (slower)
          const nextX = this.pacman.x + this.getDirectionX(this.pacman.nextDirection);
          const nextY = this.pacman.y + this.getDirectionY(this.pacman.nextDirection);
          
          if (this.isWalkable(nextX, nextY)) {
            this.pacman.direction = this.pacman.nextDirection;
            this.pacman.x = nextX;
            this.pacman.y = nextY;
          } else {
            // Try to continue in current direction
            const currX = this.pacman.x + this.getDirectionX(this.pacman.direction);
            const currY = this.pacman.y + this.getDirectionY(this.pacman.direction);
            if (this.isWalkable(currX, currY)) {
              this.pacman.x = currX;
              this.pacman.y = currY;
            }
          }
          
          // Mouth animation
          this.pacman.mouthTimer++;
          if (this.pacman.mouthTimer > 8) {
            this.pacman.mouthOpen = !this.pacman.mouthOpen;
            this.pacman.mouthTimer = 0;
          }
        }
        
        // Check pellet collision
        this.checkPelletCollision();
        
        // Check power-up collision
        this.checkPowerUpCollision();
        
        // Move ghosts
        if (this.frameCount % 7 === 0) { // Ghosts move every 7 frames (slower)
          this.ghosts.forEach(ghost => {
            this.moveGhost(ghost);
          });
        }
        
        // Check ghost collision
        this.checkGhostCollision();
        
        // Check win condition
        if (this.pelletsEaten === this.totalPellets) {
          this.won = true;
          this.gameRunning = false;
          document.getElementById('gameStatus').textContent = 'ðŸŽ‰ YOU WIN! All pellets eaten!';
        }
        
        this.frameCount++;
      }
      
      getDirectionX(direction) {
        return direction === 0 ? 1 : direction === 2 ? -1 : 0;
      }
      
      getDirectionY(direction) {
        return direction === 1 ? 1 : direction === 3 ? -1 : 0;
      }
      
      isWalkable(x, y) {
        if (x < 0 || x >= this.cols || y < 0 || y >= this.rows) return false;
        return this.maze[y][x] === 0;
      }
      
      checkPelletCollision() {
        this.pellets.forEach(pellet => {
          if (pellet.x === this.pacman.x && pellet.y === this.pacman.y && !pellet.eaten) {
            pellet.eaten = true;
            this.score += 10;
            this.pelletsEaten++;
            this.updateUI();
          }
        });
      }
      
      checkPowerUpCollision() {
        this.powerUps.forEach(powerUp => {
          if (powerUp.x === this.pacman.x && powerUp.y === this.pacman.y && !powerUp.eaten) {
            powerUp.eaten = true;
            this.powerUpActive = true;
            this.powerUpTimer = this.powerUpDuration;
            this.score += 50;
            this.ghosts.forEach(g => g.mode = 'scatter');
            this.updateUI();
          }
        });
      }
      
      moveGhost(ghost) {
        // Determine ghost target based on personality (for splitting up)
        let targetX, targetY;
        
        if (this.powerUpActive) {
          // All ghosts run away during power-up
          targetX = this.pacman.x;
          targetY = this.pacman.y;
        } else {
          // Each ghost has unique behavior
          if (ghost.name === 'Blinky') {
            // Red ghost: Direct chase to Pac-Man
            targetX = this.pacman.x;
            targetY = this.pacman.y;
          } else if (ghost.name === 'Pinky') {
            // Pink ghost: Chase ahead of Pac-Man but less accurately
            const aheadDistance = 2;
            targetX = this.pacman.x + this.getDirectionX(this.pacman.direction) * aheadDistance;
            targetY = this.pacman.y + this.getDirectionY(this.pacman.direction) * aheadDistance;
          } else if (ghost.name === 'Inky') {
            // Cyan ghost: Weaker ambush - random factor makes it less precise
            const blinky = this.ghosts[0];
            const randomOffset = Math.random() * 3 - 1.5;
            targetX = this.pacman.x + (this.pacman.x - blinky.x) / 4 + randomOffset;
            targetY = this.pacman.y + (this.pacman.y - blinky.y) / 4 + randomOffset;
          } else if (ghost.name === 'Clyde') {
            // Orange ghost: Chase Pac-Man if far, retreat to corner if close
            const distance = Math.abs(ghost.x - this.pacman.x) + Math.abs(ghost.y - this.pacman.y);
            if (distance > 12) {
              targetX = this.pacman.x;
              targetY = this.pacman.y;
            } else {
              // Retreat to bottom-right corner
              targetX = 26;
              targetY = 26;
            }
          }
        }
        
        // Pathfinding: evaluate moves and pick best one
        let possibleMoves = [];
        const directions = [0, 1, 2, 3];
        
        directions.forEach(dir => {
          const nx = ghost.x + this.getDirectionX(dir);
          const ny = ghost.y + this.getDirectionY(dir);
          if (this.isWalkable(nx, ny)) {
            // Calculate Manhattan distance to target
            let distance = Math.abs(nx - targetX) + Math.abs(ny - targetY);
            possibleMoves.push({ dir, x: nx, y: ny, distance });
          }
        });
        
        if (possibleMoves.length > 0) {
          if (this.powerUpActive) {
            // Run away: choose furthest from Pac-Man
            possibleMoves.sort((a, b) => b.distance - a.distance);
          } else {
            // Chase: choose closest to target
            possibleMoves.sort((a, b) => a.distance - b.distance);
          }
          
          ghost.x = possibleMoves[0].x;
          ghost.y = possibleMoves[0].y;
        }
      }
      
      checkGhostCollision() {
        this.ghosts.forEach(ghost => {
          if (ghost.x === this.pacman.x && ghost.y === this.pacman.y) {
            if (this.powerUpActive) {
              // Eat ghost
              ghost.x = 13;
              ghost.y = 9;
              this.score += 100;
              this.updateUI();
            } else {
              // Lose life
              this.lives--;
              this.updateUI();
              
              if (this.lives <= 0) {
                this.gameRunning = false;
                document.getElementById('gameStatus').textContent = 'ðŸ’€ GAME OVER! No more lives!';
              } else {
                // Reset positions
                this.pacman.x = 13;
                this.pacman.y = 23;
                this.ghosts.forEach((g, i) => {
                  g.x = 12 + i - 1;
                  g.y = 9;
                });
              }
            }
          }
        });
      }
      
      updateUI() {
        document.getElementById('score').textContent = this.score;
        document.getElementById('lives').textContent = this.lives;
        document.getElementById('pelletsLeft').textContent = this.totalPellets - this.pelletsEaten;
      }
      
      draw() {
        // Get computed styles for theme colors
        const wallColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
        
        // Clear canvas with black background
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw maze walls with theme accent
        this.ctx.fillStyle = wallColor || '#2563eb';
        for (let y = 0; y < this.rows; y++) {
          for (let x = 0; x < this.cols; x++) {
            if (this.maze[y][x] === 1) {
              this.ctx.fillRect(x * this.gridSize, y * this.gridSize, this.gridSize, this.gridSize);
            }
          }
        }
        
        // Draw pellets
        this.ctx.fillStyle = '#FFB8DB';
        this.pellets.forEach(pellet => {
          if (!pellet.eaten) {
            this.ctx.fillRect(
              pellet.x * this.gridSize + 8,
              pellet.y * this.gridSize + 8,
              4,
              4
            );
          }
        });
        
        // Draw power-ups
        const pulse = (Math.sin(this.frameCount / 10) + 1) / 2;
        this.ctx.fillStyle = `rgba(255, 184, 219, ${0.5 + pulse * 0.5})`;
        this.powerUps.forEach(powerUp => {
          if (!powerUp.eaten) {
            this.ctx.beginPath();
            this.ctx.arc(
              powerUp.x * this.gridSize + 10,
              powerUp.y * this.gridSize + 10,
              6 + pulse * 2,
              0,
              Math.PI * 2
            );
            this.ctx.fill();
          }
        });
        
        // Draw Pac-Man
        this.drawPacMan();
        
        // Draw ghosts
        this.ghosts.forEach(ghost => {
          this.drawGhost(ghost);
        });
      }
      
      drawPacMan() {
        const x = this.pacman.x * this.gridSize + 10;
        const y = this.pacman.y * this.gridSize + 10;
        const radius = 8;
        
        this.ctx.fillStyle = '#FFFF00';
        this.ctx.beginPath();
        
        let mouthAngle = this.pacman.mouthOpen ? 0.3 : 0;
        const startAngle = this.pacman.direction * Math.PI / 2 + mouthAngle;
        const endAngle = this.pacman.direction * Math.PI / 2 + Math.PI * 2 - mouthAngle;
        
        this.ctx.arc(x, y, radius, startAngle, endAngle);
        this.ctx.lineTo(x, y);
        this.ctx.fill();
      }
      
      drawGhost(ghost) {
        const x = ghost.x * this.gridSize;
        const y = ghost.y * this.gridSize;
        
        this.ctx.fillStyle = ghost.mode === 'scatter' && this.powerUpActive ? '#0033FF' : ghost.color;
        
        // Ghost body
        this.ctx.fillRect(x + 2, y + 2, 16, 14);
        this.ctx.beginPath();
        this.ctx.arc(x + 10, y + 8, 8, Math.PI, 0);
        this.ctx.fill();
        
        // Ghost bumps
        for (let i = 0; i < 4; i++) {
          this.ctx.fillRect(x + 3 + i * 4, y + 16, 2, 2);
        }
        
        // Ghost eyes
        this.ctx.fillStyle = '#FFF';
        this.ctx.fillRect(x + 5, y + 6, 2, 2);
        this.ctx.fillRect(x + 11, y + 6, 2, 2);
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(x + 6, y + 6, 1, 1);
        this.ctx.fillRect(x + 12, y + 6, 1, 1);
      }
    }
    
    // Start game with sound
    function startGameWithSound() {
      const pacmanMusic = document.getElementById('pacmanMusic');
      if (pacmanGame && !pacmanGame.gameRunning) {
        pacmanGame.startGame();
        // Try to play the music (may be blocked by browser autoplay policies)
        const playPromise = pacmanMusic.play();
        if (playPromise !== undefined) {
          playPromise.catch(error => {
            console.log('Audio play was prevented:', error);
            // Autoplay was prevented, we'll try again on a user gesture
            document.addEventListener('click', function enableAudio() {
              pacmanMusic.play().catch(e => console.log('Audio play failed:', e));
              document.removeEventListener('click', enableAudio);
            }, { once: true });
          });
        }
      }
    }

    // Initialize game
    let pacmanGame;
    document.addEventListener('DOMContentLoaded', () => {
      pacmanGame = new PacManGame();
    });
  </script>
</body>
</html>
